{"version":3,"sources":["../../../src/core/tool/toolResultStream.ts"],"sourcesContent":["import { Tool, ToolCallReader, ToolExecuteFunction } from \"./tool-types\";\nimport { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport { ToolResponse } from \"./ToolResponse\";\nimport { ToolExecutionStream } from \"./ToolExecutionStream\";\nimport { AssistantMessage } from \"../utils/types\";\nimport { ReadonlyJSONObject, ReadonlyJSONValue } from \"../../utils\";\n\nconst isStandardSchemaV1 = (\n  schema: unknown,\n): schema is StandardSchemaV1<unknown> => {\n  return (\n    typeof schema === \"object\" &&\n    schema !== null &&\n    \"~standard\" in schema &&\n    (schema as StandardSchemaV1<unknown>)[\"~standard\"].version === 1\n  );\n};\n\nfunction getToolResponse(\n  tools: Record<string, Tool> | undefined,\n  abortSignal: AbortSignal,\n  toolCall: {\n    toolCallId: string;\n    toolName: string;\n    args: ReadonlyJSONObject;\n  },\n  human: (toolCallId: string, payload: unknown) => Promise<unknown>,\n) {\n  const tool = tools?.[toolCall.toolName];\n  if (!tool || !tool.execute) return undefined;\n\n  const getResult = async (\n    toolExecute: ToolExecuteFunction<ReadonlyJSONObject, unknown>,\n  ): Promise<ToolResponse<ReadonlyJSONValue>> => {\n    let executeFn = toolExecute;\n\n    if (isStandardSchemaV1(tool.parameters)) {\n      let result = tool.parameters[\"~standard\"].validate(toolCall.args);\n      if (result instanceof Promise) result = await result;\n\n      if (result.issues) {\n        executeFn =\n          tool.experimental_onSchemaValidationError ??\n          (() => {\n            throw new Error(\n              `Function parameter validation failed. ${JSON.stringify(result.issues)}`,\n            );\n          });\n      }\n    }\n\n    const result = (await executeFn(toolCall.args, {\n      toolCallId: toolCall.toolCallId,\n      abortSignal,\n      human: (payload: unknown) => human(toolCall.toolCallId, payload),\n    })) as unknown as ReadonlyJSONValue;\n    return ToolResponse.toResponse(result);\n  };\n\n  return getResult(tool.execute);\n}\n\nfunction getToolStreamResponse(\n  tools: Record<string, Tool> | undefined,\n  abortSignal: AbortSignal,\n  reader: ToolCallReader<any, ReadonlyJSONValue>,\n  context: {\n    toolCallId: string;\n    toolName: string;\n  },\n  human: (toolCallId: string, payload: unknown) => Promise<unknown>,\n) {\n  tools?.[context.toolName]?.streamCall?.(reader, {\n    toolCallId: context.toolCallId,\n    abortSignal,\n    human: (payload: unknown) => human(context.toolCallId, payload),\n  });\n}\n\nexport async function unstable_runPendingTools(\n  message: AssistantMessage,\n  tools: Record<string, Tool> | undefined,\n  abortSignal: AbortSignal,\n  human: (toolCallId: string, payload: unknown) => Promise<unknown>,\n) {\n  const toolCallPromises = message.parts\n    .filter((part) => part.type === \"tool-call\")\n    .map(async (part) => {\n      const promiseOrUndefined = getToolResponse(\n        tools,\n        abortSignal,\n        part,\n        human ??\n          (async () => {\n            throw new Error(\n              \"Tool human input is not supported in this context\",\n            );\n          }),\n      );\n      if (promiseOrUndefined) {\n        const result = await promiseOrUndefined;\n        return {\n          toolCallId: part.toolCallId,\n          result,\n        };\n      }\n      return null;\n    });\n\n  const toolCallResults = (await Promise.all(toolCallPromises)).filter(\n    (result) => result !== null,\n  ) as { toolCallId: string; result: ToolResponse<ReadonlyJSONValue> }[];\n\n  if (toolCallResults.length === 0) {\n    return message;\n  }\n\n  const toolCallResultsById = toolCallResults.reduce(\n    (acc, { toolCallId, result }) => {\n      acc[toolCallId] = result;\n      return acc;\n    },\n    {} as Record<string, ToolResponse<ReadonlyJSONValue>>,\n  );\n\n  const updatedParts = message.parts.map((p) => {\n    if (p.type === \"tool-call\") {\n      const toolResponse = toolCallResultsById[p.toolCallId];\n      if (toolResponse) {\n        return {\n          ...p,\n          state: \"result\" as const,\n          ...(toolResponse.artifact !== undefined\n            ? { artifact: toolResponse.artifact }\n            : {}),\n          result: toolResponse.result as ReadonlyJSONValue,\n          isError: toolResponse.isError,\n        };\n      }\n    }\n    return p;\n  });\n\n  return {\n    ...message,\n    parts: updatedParts,\n    content: updatedParts,\n  };\n}\n\nexport function toolResultStream(\n  tools:\n    | Record<string, Tool>\n    | (() => Record<string, Tool> | undefined)\n    | undefined,\n  abortSignal: AbortSignal | (() => AbortSignal),\n  human: (toolCallId: string, payload: unknown) => Promise<unknown>,\n) {\n  const toolsFn = typeof tools === \"function\" ? tools : () => tools;\n  const abortSignalFn =\n    typeof abortSignal === \"function\" ? abortSignal : () => abortSignal;\n  return new ToolExecutionStream({\n    execute: (toolCall) =>\n      getToolResponse(toolsFn(), abortSignalFn(), toolCall, human),\n    streamCall: ({ reader, ...context }) =>\n      getToolStreamResponse(toolsFn(), abortSignalFn(), reader, context, human),\n  });\n}\n"],"mappings":"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","names":["result"]}