{"version":3,"sources":["../../../src/ui/use-chat/useAISDKRuntime.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useMemo } from \"react\";\nimport type { UIMessage, useChat, CreateUIMessage } from \"@ai-sdk/react\";\nimport {\n  useExternalStoreRuntime,\n  ExternalStoreAdapter,\n  ThreadHistoryAdapter,\n  AssistantRuntime,\n  ThreadMessage,\n  MessageFormatAdapter,\n  useRuntimeAdapters,\n  INTERNAL,\n  type ToolExecutionStatus,\n  AppendMessage,\n} from \"@assistant-ui/react\";\nimport { sliceMessagesUntil } from \"../utils/sliceMessagesUntil\";\nimport { toCreateMessage } from \"../utils/toCreateMessage\";\n\nexport type CustomToCreateMessageFunction = <\n  UI_MESSAGE extends UIMessage = UIMessage,\n>(\n  message: AppendMessage,\n) => CreateUIMessage<UI_MESSAGE>;\n\nimport { vercelAttachmentAdapter } from \"../utils/vercelAttachmentAdapter\";\nimport { getVercelAIMessages } from \"../getVercelAIMessages\";\nimport { AISDKMessageConverter } from \"../utils/convertMessage\";\nimport {\n  AISDKStorageFormat,\n  aiSDKV5FormatAdapter,\n} from \"../adapters/aiSDKFormatAdapter\";\nimport { useExternalHistory } from \"./useExternalHistory\";\n\nexport type AISDKRuntimeAdapter = {\n  adapters?:\n    | (NonNullable<ExternalStoreAdapter[\"adapters\"]> & {\n        history?: ThreadHistoryAdapter | undefined;\n      })\n    | undefined;\n  toCreateMessage?: CustomToCreateMessageFunction;\n};\n\nexport const useAISDKRuntime = <UI_MESSAGE extends UIMessage = UIMessage>(\n  chatHelpers: ReturnType<typeof useChat<UI_MESSAGE>>,\n  {\n    adapters,\n    toCreateMessage: customToCreateMessage,\n  }: AISDKRuntimeAdapter = {},\n) => {\n  const contextAdapters = useRuntimeAdapters();\n  const isRunning =\n    chatHelpers.status === \"submitted\" || chatHelpers.status == \"streaming\";\n\n  const [toolStatuses, setToolStatuses] = useState<\n    Record<string, ToolExecutionStatus>\n  >({});\n\n  const messages = AISDKMessageConverter.useThreadMessages({\n    isRunning,\n    messages: chatHelpers.messages,\n    metadata: useMemo(\n      () => ({\n        toolStatuses,\n        ...(chatHelpers.error && { error: chatHelpers.error.message }),\n      }),\n      [toolStatuses, chatHelpers.error],\n    ),\n  });\n\n  const [runtimeRef] = useState(() => ({\n    get current(): AssistantRuntime {\n      return runtime;\n    },\n  }));\n\n  const toolInvocations = INTERNAL.useToolInvocations({\n    state: {\n      messages,\n      isRunning,\n    },\n    getTools: () => runtimeRef.current.thread.getModelContext().tools,\n    onResult: (command: any) => {\n      if (command.type === \"add-tool-result\") {\n        chatHelpers.addToolResult({\n          tool: command.toolName,\n          toolCallId: command.toolCallId,\n          output: command.result,\n        });\n      }\n    },\n    setToolStatuses,\n  });\n\n  const isLoading = useExternalHistory(\n    runtimeRef,\n    adapters?.history ?? contextAdapters?.history,\n    AISDKMessageConverter.toThreadMessages as (\n      messages: UI_MESSAGE[],\n    ) => ThreadMessage[],\n    aiSDKV5FormatAdapter as MessageFormatAdapter<\n      UI_MESSAGE,\n      AISDKStorageFormat\n    >,\n    (messages) => {\n      chatHelpers.setMessages(messages);\n    },\n  );\n\n  const runtime = useExternalStoreRuntime({\n    isRunning,\n    messages,\n    setMessages: (messages) =>\n      chatHelpers.setMessages(\n        messages\n          .map(getVercelAIMessages<UI_MESSAGE>)\n          .filter(Boolean)\n          .flat(),\n      ),\n    onImport: (messages) =>\n      chatHelpers.setMessages(\n        messages\n          .map(getVercelAIMessages<UI_MESSAGE>)\n          .filter(Boolean)\n          .flat(),\n      ),\n    onCancel: async () => {\n      chatHelpers.stop();\n      toolInvocations.abort();\n    },\n    onNew: async (message) => {\n      const createMessage = (\n        customToCreateMessage ?? toCreateMessage\n      )<UI_MESSAGE>(message);\n      await chatHelpers.sendMessage(createMessage, {\n        metadata: message.runConfig,\n      });\n    },\n    onEdit: async (message) => {\n      const newMessages = sliceMessagesUntil(\n        chatHelpers.messages,\n        message.parentId,\n      );\n      chatHelpers.setMessages(newMessages);\n\n      const createMessage = (\n        customToCreateMessage ?? toCreateMessage\n      )<UI_MESSAGE>(message);\n      await chatHelpers.sendMessage(createMessage, {\n        metadata: message.runConfig,\n      });\n    },\n    onReload: async (parentId: string | null, config) => {\n      const newMessages = sliceMessagesUntil(chatHelpers.messages, parentId);\n      chatHelpers.setMessages(newMessages);\n\n      await chatHelpers.regenerate({ metadata: config.runConfig });\n    },\n    onAddToolResult: ({ toolCallId, result, isError }) => {\n      if (isError) {\n        chatHelpers.addToolOutput({\n          state: \"output-error\",\n          tool: toolCallId,\n          toolCallId,\n          errorText:\n            typeof result === \"string\" ? result : JSON.stringify(result),\n        });\n      } else {\n        chatHelpers.addToolOutput({\n          state: \"output-available\",\n          tool: toolCallId,\n          toolCallId,\n          output: result,\n        });\n      }\n    },\n    onResumeToolCall: (options) =>\n      toolInvocations.resume(options.toolCallId, options.payload),\n    adapters: {\n      attachments: vercelAttachmentAdapter,\n      ...contextAdapters,\n      ...adapters,\n    },\n    isLoading,\n  });\n\n  return runtime;\n};\n"],"mappings":"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","names":["messages"]}