"use client";

// src/ui/use-chat/useAISDKRuntime.tsx
import { useState, useMemo } from "react";
import {
  useExternalStoreRuntime,
  useRuntimeAdapters,
  INTERNAL
} from "@assistant-ui/react";
import { sliceMessagesUntil } from "../utils/sliceMessagesUntil.js";
import { toCreateMessage } from "../utils/toCreateMessage.js";
import { vercelAttachmentAdapter } from "../utils/vercelAttachmentAdapter.js";
import { getVercelAIMessages } from "../getVercelAIMessages.js";
import { AISDKMessageConverter } from "../utils/convertMessage.js";
import {
  aiSDKV5FormatAdapter
} from "../adapters/aiSDKFormatAdapter.js";
import { useExternalHistory } from "./useExternalHistory.js";
var useAISDKRuntime = (chatHelpers, {
  adapters,
  toCreateMessage: customToCreateMessage
} = {}) => {
  const contextAdapters = useRuntimeAdapters();
  const isRunning = chatHelpers.status === "submitted" || chatHelpers.status == "streaming";
  const [toolStatuses, setToolStatuses] = useState({});
  const messages = AISDKMessageConverter.useThreadMessages({
    isRunning,
    messages: chatHelpers.messages,
    metadata: useMemo(
      () => ({
        toolStatuses,
        ...chatHelpers.error && { error: chatHelpers.error.message }
      }),
      [toolStatuses, chatHelpers.error]
    )
  });
  const [runtimeRef] = useState(() => ({
    get current() {
      return runtime;
    }
  }));
  const toolInvocations = INTERNAL.useToolInvocations({
    state: {
      messages,
      isRunning
    },
    getTools: () => runtimeRef.current.thread.getModelContext().tools,
    onResult: (command) => {
      if (command.type === "add-tool-result") {
        chatHelpers.addToolResult({
          tool: command.toolName,
          toolCallId: command.toolCallId,
          output: command.result
        });
      }
    },
    setToolStatuses
  });
  const isLoading = useExternalHistory(
    runtimeRef,
    adapters?.history ?? contextAdapters?.history,
    AISDKMessageConverter.toThreadMessages,
    aiSDKV5FormatAdapter,
    (messages2) => {
      chatHelpers.setMessages(messages2);
    }
  );
  const runtime = useExternalStoreRuntime({
    isRunning,
    messages,
    setMessages: (messages2) => chatHelpers.setMessages(
      messages2.map(getVercelAIMessages).filter(Boolean).flat()
    ),
    onImport: (messages2) => chatHelpers.setMessages(
      messages2.map(getVercelAIMessages).filter(Boolean).flat()
    ),
    onCancel: async () => {
      chatHelpers.stop();
      toolInvocations.abort();
    },
    onNew: async (message) => {
      const createMessage = (customToCreateMessage ?? toCreateMessage)(message);
      await chatHelpers.sendMessage(createMessage, {
        metadata: message.runConfig
      });
    },
    onEdit: async (message) => {
      const newMessages = sliceMessagesUntil(
        chatHelpers.messages,
        message.parentId
      );
      chatHelpers.setMessages(newMessages);
      const createMessage = (customToCreateMessage ?? toCreateMessage)(message);
      await chatHelpers.sendMessage(createMessage, {
        metadata: message.runConfig
      });
    },
    onReload: async (parentId, config) => {
      const newMessages = sliceMessagesUntil(chatHelpers.messages, parentId);
      chatHelpers.setMessages(newMessages);
      await chatHelpers.regenerate({ metadata: config.runConfig });
    },
    onAddToolResult: ({ toolCallId, result, isError }) => {
      if (isError) {
        chatHelpers.addToolOutput({
          state: "output-error",
          tool: toolCallId,
          toolCallId,
          errorText: typeof result === "string" ? result : JSON.stringify(result)
        });
      } else {
        chatHelpers.addToolOutput({
          state: "output-available",
          tool: toolCallId,
          toolCallId,
          output: result
        });
      }
    },
    onResumeToolCall: (options) => toolInvocations.resume(options.toolCallId, options.payload),
    adapters: {
      attachments: vercelAttachmentAdapter,
      ...contextAdapters,
      ...adapters
    },
    isLoading
  });
  return runtime;
};
export {
  useAISDKRuntime
};
//# sourceMappingURL=useAISDKRuntime.js.map