"use client";

// src/ui/use-chat/useExternalHistory.tsx
import {
  getExternalStoreMessages,
  INTERNAL,
  useAssistantApi
} from "@assistant-ui/react";
import { useRef, useEffect, useState, useCallback } from "react";
var { MessageRepository } = INTERNAL;
var toExportedMessageRepository = (toThreadMessages, messages) => {
  return {
    headId: messages.headId,
    messages: messages.messages.map((m) => {
      const message = toThreadMessages([m.message])[0];
      return {
        ...m,
        message
      };
    })
  };
};
var useExternalHistory = (runtimeRef, historyAdapter, toThreadMessages, storageFormatAdapter, onSetMessages) => {
  const loadedRef = useRef(false);
  const api = useAssistantApi();
  const optionalThreadListItem = useCallback(
    () => api.threadListItem.source ? api.threadListItem() : null,
    [api]
  );
  const [isLoading, setIsLoading] = useState(false);
  const historyIds = useRef(/* @__PURE__ */ new Set());
  const onSetMessagesRef = useRef(() => onSetMessages);
  useEffect(() => {
    onSetMessagesRef.current = onSetMessages;
  });
  useEffect(() => {
    if (!historyAdapter || loadedRef.current) return;
    const loadHistory = async () => {
      setIsLoading(true);
      try {
        const repo = await historyAdapter.withFormat?.(storageFormatAdapter).load();
        if (repo && repo.messages.length > 0) {
          const converted = toExportedMessageRepository(toThreadMessages, repo);
          runtimeRef.current.thread.import(converted);
          const tempRepo = new MessageRepository();
          tempRepo.import(converted);
          const messages = tempRepo.getMessages();
          onSetMessagesRef.current(
            messages.map(getExternalStoreMessages).flat()
          );
          historyIds.current = new Set(
            converted.messages.map((m) => m.message.id)
          );
        }
      } catch (error) {
        console.error("Failed to load message history:", error);
      } finally {
        setIsLoading(false);
      }
    };
    if (!loadedRef.current) {
      loadedRef.current = true;
      if (!optionalThreadListItem()?.getState().remoteId) {
        setIsLoading(false);
        return;
      }
      loadHistory();
    }
  }, [
    api,
    historyAdapter,
    storageFormatAdapter,
    toThreadMessages,
    runtimeRef,
    optionalThreadListItem
  ]);
  useEffect(() => {
    return runtimeRef.current.thread.subscribe(async () => {
      const { messages, isRunning } = runtimeRef.current.thread.getState();
      if (isRunning) return;
      for (let i = 0; i < messages.length; i++) {
        const message = messages[i];
        if (message.status === void 0 || message.status.type === "complete" || message.status.type === "incomplete") {
          if (historyIds.current.has(message.id)) continue;
          historyIds.current.add(message.id);
          const parentId = i > 0 ? messages[i - 1].id : null;
          await historyAdapter?.withFormat?.(storageFormatAdapter).append({
            parentId,
            message: getExternalStoreMessages(message)[0]
          });
        }
      }
    });
  }, [historyAdapter, storageFormatAdapter, runtimeRef]);
  return isLoading;
};
export {
  toExportedMessageRepository,
  useExternalHistory
};
//# sourceMappingURL=useExternalHistory.js.map