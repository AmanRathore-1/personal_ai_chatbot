{"version":3,"sources":["../../../src/primitives/reasoning/useScrollLock.tsx"],"sourcesContent":["\"use client\";\n\nimport { type RefObject, useCallback, useEffect, useRef } from \"react\";\n\n/**\n * Locks scroll position during collapsible/height animations and hides scrollbar.\n *\n * This utility prevents page jumps when content height changes during animations,\n * providing a smooth user experience. It finds the nearest scrollable ancestor and\n * temporarily locks its scroll position while the animation completes.\n *\n * - Prevents forced reflows: no layout reads, mutations scoped to scrollable parent only\n * - Reactive: only intercepts scroll events when browser actually adjusts\n * - Cleans up automatically after animation duration\n *\n * @param animatedElementRef - Ref to the animated element\n * @param animationDuration - Lock duration in milliseconds\n * @returns Function to activate the scroll lock\n *\n * @example\n * ```tsx\n * const collapsibleRef = useRef<HTMLDivElement>(null);\n * const lockScroll = useScrollLock(collapsibleRef, 200);\n *\n * const handleCollapse = () => {\n *   lockScroll(); // Lock scroll before collapsing\n *   setIsOpen(false);\n * };\n * ```\n */\nexport const useScrollLock = <T extends HTMLElement = HTMLElement>(\n  animatedElementRef: RefObject<T | null>,\n  animationDuration: number,\n) => {\n  const scrollContainerRef = useRef<HTMLElement | null>(null);\n  const cleanupRef = useRef<(() => void) | null>(null);\n\n  useEffect(() => {\n    return () => {\n      cleanupRef.current?.();\n    };\n  }, []);\n\n  const lockScroll = useCallback(() => {\n    cleanupRef.current?.();\n\n    (function findScrollableAncestor() {\n      if (scrollContainerRef.current || !animatedElementRef.current) return;\n\n      let el: HTMLElement | null = animatedElementRef.current;\n      while (el) {\n        const { overflowY } = getComputedStyle(el);\n        if (overflowY === \"scroll\" || overflowY === \"auto\") {\n          scrollContainerRef.current = el;\n          break;\n        }\n        el = el.parentElement;\n      }\n    })();\n\n    const scrollContainer = scrollContainerRef.current;\n    if (!scrollContainer) return;\n\n    const scrollPosition = scrollContainer.scrollTop;\n    const scrollbarWidth = scrollContainer.style.scrollbarWidth;\n\n    scrollContainer.style.scrollbarWidth = \"none\";\n\n    const resetPosition = () => (scrollContainer.scrollTop = scrollPosition);\n    scrollContainer.addEventListener(\"scroll\", resetPosition);\n\n    const timeoutId = setTimeout(() => {\n      scrollContainer.removeEventListener(\"scroll\", resetPosition);\n      scrollContainer.style.scrollbarWidth = scrollbarWidth;\n      cleanupRef.current = null;\n    }, animationDuration);\n\n    cleanupRef.current = () => {\n      clearTimeout(timeoutId);\n      scrollContainer.removeEventListener(\"scroll\", resetPosition);\n      scrollContainer.style.scrollbarWidth = scrollbarWidth;\n    };\n  }, [animationDuration, animatedElementRef]);\n\n  return lockScroll;\n};\n"],"mappings":";;;AAEA,SAAyB,aAAa,WAAW,cAAc;AA4BxD,IAAM,gBAAgB,CAC3B,oBACA,sBACG;AACH,QAAM,qBAAqB,OAA2B,IAAI;AAC1D,QAAM,aAAa,OAA4B,IAAI;AAEnD,YAAU,MAAM;AACd,WAAO,MAAM;AACX,iBAAW,UAAU;AAAA,IACvB;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,QAAM,aAAa,YAAY,MAAM;AACnC,eAAW,UAAU;AAErB,KAAC,SAAS,yBAAyB;AACjC,UAAI,mBAAmB,WAAW,CAAC,mBAAmB,QAAS;AAE/D,UAAI,KAAyB,mBAAmB;AAChD,aAAO,IAAI;AACT,cAAM,EAAE,UAAU,IAAI,iBAAiB,EAAE;AACzC,YAAI,cAAc,YAAY,cAAc,QAAQ;AAClD,6BAAmB,UAAU;AAC7B;AAAA,QACF;AACA,aAAK,GAAG;AAAA,MACV;AAAA,IACF,GAAG;AAEH,UAAM,kBAAkB,mBAAmB;AAC3C,QAAI,CAAC,gBAAiB;AAEtB,UAAM,iBAAiB,gBAAgB;AACvC,UAAM,iBAAiB,gBAAgB,MAAM;AAE7C,oBAAgB,MAAM,iBAAiB;AAEvC,UAAM,gBAAgB,MAAO,gBAAgB,YAAY;AACzD,oBAAgB,iBAAiB,UAAU,aAAa;AAExD,UAAM,YAAY,WAAW,MAAM;AACjC,sBAAgB,oBAAoB,UAAU,aAAa;AAC3D,sBAAgB,MAAM,iBAAiB;AACvC,iBAAW,UAAU;AAAA,IACvB,GAAG,iBAAiB;AAEpB,eAAW,UAAU,MAAM;AACzB,mBAAa,SAAS;AACtB,sBAAgB,oBAAoB,UAAU,aAAa;AAC3D,sBAAgB,MAAM,iBAAiB;AAAA,IACzC;AAAA,EACF,GAAG,CAAC,mBAAmB,kBAAkB,CAAC;AAE1C,SAAO;AACT;","names":[]}