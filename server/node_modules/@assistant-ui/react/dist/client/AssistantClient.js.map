{"version":3,"sources":["../../src/client/AssistantClient.ts"],"sourcesContent":["import {\n  tapMemo,\n  resource,\n  Unsubscribe,\n  tapInlineResource,\n  ResourceElement,\n  tapResource,\n} from \"@assistant-ui/tap\";\nimport { ThreadListClientApi, ThreadListClientState } from \"./types/ThreadList\";\nimport { Tools } from \"../model-context\";\nimport { asStore, Store, tapApi } from \"../utils/tap-store\";\nimport { useResource } from \"@assistant-ui/tap/react\";\nimport { useMemo } from \"react\";\nimport {\n  AssistantEvent,\n  AssistantEventCallback,\n  checkEventScope,\n  normalizeEventSelector,\n} from \"../types/EventTypes\";\nimport { EventManager } from \"../legacy-runtime/client/EventManagerRuntimeClient\";\nimport {\n  AssistantApi,\n  createAssistantApiField,\n  useAssistantApiImpl,\n  extendApi,\n} from \"../context/react/AssistantApiContext\";\nimport { withEventsProvider } from \"./EventContext\";\nimport { withModelContextProvider } from \"./ModelContext\";\nimport { ToolsApi, ToolsState } from \"./types/Tools\";\nimport { ModelContextApi, ModelContextState } from \"./types/ModelContext\";\nimport { ModelContext as ModelContextResource } from \"./ModelContextClient\";\n\ntype AssistantClientState = {\n  readonly threads: ThreadListClientState;\n  readonly tools: ToolsState;\n  readonly modelContext: ModelContextState;\n};\n\ntype AssistantClientApi = {\n  getState(): AssistantClientState;\n\n  readonly threads: ThreadListClientApi;\n  readonly tools: ToolsApi;\n  readonly modelContext: ModelContextApi;\n\n  on<TEvent extends AssistantEvent>(\n    event: TEvent,\n    callback: AssistantEventCallback<TEvent>,\n  ): Unsubscribe;\n};\n\nconst AssistantStore = resource(\n  ({\n    threads: threadsEl,\n    modelContext: modelContextEl,\n    tools: toolsEl,\n  }: AssistantClientProps) => {\n    const events = tapInlineResource(EventManager());\n\n    const { threads, tools, modelContext } = withEventsProvider(events, () => {\n      const modelContextResource = tapResource(\n        modelContextEl ?? ModelContextResource(),\n        [modelContextEl],\n      );\n\n      return withModelContextProvider(modelContextResource.api, () => {\n        return {\n          modelContext: modelContextResource,\n          tools: tapResource(toolsEl ?? Tools({}), [toolsEl]),\n          threads: tapResource(threadsEl, [threadsEl]),\n        };\n      });\n    });\n\n    const state = tapMemo<AssistantClientState>(\n      () => ({\n        threads: threads.state,\n        tools: tools.state,\n        modelContext: modelContext.state,\n      }),\n      [threads.state, tools.state, modelContext.state],\n    );\n\n    return tapApi<AssistantClientApi>({\n      getState: () => state,\n\n      threads: threads.api,\n      tools: tools.api,\n      modelContext: modelContext.api,\n      on: events.on,\n    });\n  },\n);\n\nconst getClientFromStore = (client: Store<{ api: AssistantClientApi }>) => {\n  const getItem = () => {\n    return client.getState().api.threads.item(\"main\");\n  };\n  return {\n    threads: createAssistantApiField({\n      source: \"root\",\n      query: {},\n      get: () => client.getState().api.threads,\n    }),\n    tools: createAssistantApiField({\n      source: \"root\",\n      query: {},\n      get: () => client.getState().api.tools,\n    }),\n    modelContext: createAssistantApiField({\n      source: \"root\",\n      query: {},\n      get: () => client.getState().api.modelContext,\n    }),\n    thread: createAssistantApiField({\n      source: \"threads\",\n      query: { type: \"main\" },\n      get: () => client.getState().api.threads.thread(\"main\"),\n    }),\n    threadListItem: createAssistantApiField({\n      source: \"threads\",\n      query: { type: \"main\" },\n      get: () => getItem(),\n    }),\n    composer: createAssistantApiField({\n      source: \"thread\",\n      query: {},\n      get: () => client.getState().api.threads.thread(\"main\").composer,\n    }),\n    on(selector, callback) {\n      const { event, scope } = normalizeEventSelector(selector);\n      if (scope === \"*\") return client.getState().api.on(event, callback);\n\n      if (\n        checkEventScope(\"thread\", scope, event) ||\n        checkEventScope(\"thread-list-item\", scope, event) ||\n        checkEventScope(\"composer\", scope, event)\n      ) {\n        return client.getState().api.on(event, (e) => {\n          if (e.threadId !== getItem().getState().id) return;\n          callback(e);\n        });\n      }\n\n      throw new Error(\n        `Event scope is not available in this component: ${scope}`,\n      );\n    },\n    subscribe: client.subscribe,\n    flushSync: client.flushSync,\n  } satisfies Partial<AssistantApi>;\n};\n\nexport type AssistantClientProps = {\n  threads: ResourceElement<{\n    state: ThreadListClientState;\n    api: ThreadListClientApi;\n  }>;\n  modelContext?: ResourceElement<{\n    state: ModelContextState;\n    api: ModelContextApi;\n  }>;\n  tools?:\n    | ResourceElement<{\n        state: ToolsState;\n        api: ToolsApi;\n      }>\n    | undefined;\n};\n\nexport const useAssistantClient = (props: AssistantClientProps) => {\n  const api = useAssistantApiImpl();\n  const client = useResource(asStore(AssistantStore(props)));\n  const clientApi = useMemo(() => getClientFromStore(client), [client]);\n  return useMemo(() => extendApi(api, clientApi), [api, clientApi]);\n};\n"],"mappings":"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","names":[]}